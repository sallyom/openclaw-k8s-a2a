#!/usr/bin/env bash
# ============================================================================
# FIRST-TIME DEPLOYMENT SCRIPT
# ============================================================================
# Use this for complete deployment of OpenClaw + Agents
#
# Usage:
#   ./setup.sh                    # Deploy to OpenShift (default, no A2A)
#   ./setup.sh --with-a2a         # Deploy with A2A bridge + AuthBridge sidecars
#   ./setup.sh --k8s              # Deploy to vanilla Kubernetes (minikube, kind, etc.)
#   ./setup.sh --k8s --with-a2a   # K8s with A2A
#
# This script:
#   - Generates all secrets (gateway, OAuth) into .env
#   - Runs envsubst on committed .envsubst templates to produce deployment YAML
#   - Creates namespace (openclaw)
#   - Deploys OpenClaw gateway with security hardening:
#       * NetworkPolicy (network isolation)
#       * ResourceQuota (namespace limits: 4 CPU, 8Gi RAM)
#       * PodDisruptionBudget (high availability)
#       * Read-only root filesystem
#       * Health probes (liveness & readiness)
#       * Device authentication enabled
#       * Non-root containers with dropped capabilities
#   - Optionally deploys AI agents with RBAC
#   - Sets up cron jobs for autonomous tasks
#
# IMPORTANT:
#   - .envsubst templates are committed to Git (contain ${VAR} placeholders)
#   - .env file is generated by this script (real secrets) — NEVER commit!
#   - Generated .yaml files (from envsubst) are gitignored — NEVER commit!
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Parse flags
K8S_MODE=false
A2A_ENABLED=false
for arg in "$@"; do
  case "$arg" in
    --k8s) K8S_MODE=true ;;
    --with-a2a) A2A_ENABLED=true ;;
  esac
done

# CLI tool selection
if $K8S_MODE; then
  KUBECTL="kubectl"
else
  KUBECTL="oc"
fi

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m'

log_info() {
  echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
  echo -e "${GREEN}✅ $1${NC}"
}

log_warn() {
  echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
  echo -e "${RED}❌ $1${NC}"
}

# Apply a manifest with openclaw namespace replaced by $OPENCLAW_NAMESPACE
# Used for files applied directly (not through kustomize overlay)
apply_openclaw() {
  sed "s/namespace: openclaw/namespace: $OPENCLAW_NAMESPACE/g" "$1" | $KUBECTL apply -f -
}

# Generate random base64-encoded secret (OpenShift compatible)
generate_secret() {
  openssl rand -base64 32
}

# Generate 32-byte cookie secret (for oauth-proxy, must be exactly 16, 24, or 32 bytes)
generate_cookie_secret() {
  # Generate 32 random characters (32 bytes)
  # Use openssl instead of tr|head to avoid SIGPIPE exit under pipefail
  openssl rand -hex 16
}

echo ""
echo "╔════════════════════════════════════════════════════════════╗"
if $K8S_MODE; then
echo "║  OpenClaw Deployment Setup (Kubernetes mode)               ║"
else
echo "║  OpenClaw Deployment Setup (OpenShift mode)                ║"
fi
echo "╚════════════════════════════════════════════════════════════╝"
echo ""

# Check prerequisites
log_info "Checking prerequisites..."

if $K8S_MODE; then
  if ! command -v kubectl &> /dev/null; then
    log_error "kubectl CLI not found. Please install it first."
    exit 1
  fi

  if ! kubectl cluster-info &> /dev/null; then
    log_error "Cannot connect to Kubernetes cluster. Check your kubeconfig."
    exit 1
  fi

  CLUSTER_SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
  CLUSTER_USER=$(kubectl config view --minify -o jsonpath='{.contexts[0].context.user}')
  log_success "Connected to $CLUSTER_SERVER as $CLUSTER_USER"
  echo ""

  # K8s mode: no cluster domain needed (no routes)
  CLUSTER_DOMAIN=""
else
  if ! command -v oc &> /dev/null; then
    log_error "oc CLI not found. Please install it first."
    exit 1
  fi

  if ! oc whoami &> /dev/null; then
    log_error "Not logged in to OpenShift. Run 'oc login' first."
    exit 1
  fi

  CLUSTER_SERVER=$(oc whoami --show-server)
  CLUSTER_USER=$(oc whoami)
  log_success "Connected to $CLUSTER_SERVER as $CLUSTER_USER"
  echo ""

  # Get cluster domain
  log_info "Detecting cluster domain..."
  if CLUSTER_DOMAIN=$(oc get ingresses.config/cluster -o jsonpath='{.spec.domain}' 2>/dev/null); then
    log_success "Cluster domain: $CLUSTER_DOMAIN"
  else
    log_warn "Could not auto-detect cluster domain"
    read -p "Enter cluster domain (e.g., apps.mycluster.com): " CLUSTER_DOMAIN
  fi
  echo ""
fi

# Load existing .env early so we can skip prompts on re-runs
_ENV_REUSE=false
if [ -f "$REPO_ROOT/.env" ]; then
  set -a
  # shellcheck disable=SC1091
  source "$REPO_ROOT/.env"
  set +a
  _ENV_REUSE=true
fi

# Source .env.a2a for cluster-level A2A config (Keycloak, SPIRE settings)
# Written by manifests/a2a-infra/setup-a2a-infra.sh — survives .env wipes
if [ -f "$REPO_ROOT/.env.a2a" ]; then
  set -a
  # shellcheck disable=SC1091
  source "$REPO_ROOT/.env.a2a"
  set +a
fi

# Prompt for OpenClaw namespace prefix (skip if already set from local .env)
if $_ENV_REUSE && [ -n "${OPENCLAW_PREFIX:-}" ]; then
  OPENCLAW_NAMESPACE="${OPENCLAW_PREFIX}-openclaw"
  SHADOWMAN_CUSTOM_NAME="${SHADOWMAN_CUSTOM_NAME:-shadowman}"
  SHADOWMAN_DISPLAY_NAME="${SHADOWMAN_DISPLAY_NAME:-Shadowman}"
  log_success "Re-run detected — using prefix '$OPENCLAW_PREFIX' from .env"
  log_success "  Namespace: $OPENCLAW_NAMESPACE"
  log_success "  Agent: ${SHADOWMAN_DISPLAY_NAME} (${OPENCLAW_PREFIX}_${SHADOWMAN_CUSTOM_NAME})"
  echo ""
else
  log_info "OpenClaw namespace (each team member gets their own):"
  log_info "  Format: <prefix>-openclaw (e.g., sally-openclaw, bob-openclaw)"
  echo ""
  while true; do
    read -p "  Enter your prefix: " OPENCLAW_PREFIX
    if [ -n "$OPENCLAW_PREFIX" ]; then
      break
    fi
    log_error "A prefix is required to make your OpenClaw instance unique."
    log_error "Each team member must use a different prefix (e.g., your name)."
  done
  OPENCLAW_NAMESPACE="${OPENCLAW_PREFIX}-openclaw"
  log_success "OpenClaw namespace: $OPENCLAW_NAMESPACE"
  echo ""

  # Prompt for agent name
  log_info "Your default agent is 'Shadowman'. You can customize its name."
  log_info "  This is the agent other teammates will see when you communicate via A2A."
  read -p "  Enter a name (or press Enter to keep 'Shadowman'): " CUSTOM_NAME
  if [ -n "$CUSTOM_NAME" ]; then
    SHADOWMAN_DISPLAY_NAME="$CUSTOM_NAME"
    SHADOWMAN_CUSTOM_NAME=$(echo "$CUSTOM_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '_' | tr -cd 'a-z0-9_')
    log_success "Agent: '${SHADOWMAN_DISPLAY_NAME}' (id: ${OPENCLAW_PREFIX}_${SHADOWMAN_CUSTOM_NAME})"
  else
    SHADOWMAN_CUSTOM_NAME="shadowman"
    SHADOWMAN_DISPLAY_NAME="Shadowman"
    log_info "Keeping default name: Shadowman"
  fi
  echo ""
fi

# Confirm deployment
log_warn "This will deploy OpenClaw to namespace: $OPENCLAW_NAMESPACE"
log_warn "  Agent: ${SHADOWMAN_DISPLAY_NAME} (${OPENCLAW_PREFIX}_${SHADOWMAN_CUSTOM_NAME})"
read -p "Continue? (y/N): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  log_info "Deployment cancelled"
  exit 0
fi
echo ""

# Reuse secrets from .env or generate new ones
if $_ENV_REUSE; then
  log_info "Reusing secrets from .env (delete .env to regenerate)"
  log_success "Secrets loaded from .env"
  echo ""

  # Default any missing variables to empty
  OPENCLAW_GATEWAY_TOKEN="${OPENCLAW_GATEWAY_TOKEN:-}"
  OPENCLAW_OAUTH_CLIENT_SECRET="${OPENCLAW_OAUTH_CLIENT_SECRET:-}"
  OPENCLAW_OAUTH_COOKIE_SECRET="${OPENCLAW_OAUTH_COOKIE_SECRET:-}"
  ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
  MODEL_ENDPOINT="${MODEL_ENDPOINT:-}"
  VERTEX_ENABLED="${VERTEX_ENABLED:-false}"
  GOOGLE_CLOUD_PROJECT="${GOOGLE_CLOUD_PROJECT:-}"
  GOOGLE_CLOUD_LOCATION="${GOOGLE_CLOUD_LOCATION:-}"
  VERTEX_SA_JSON_PATH="${VERTEX_SA_JSON_PATH:-}"
  # A2A: CLI flag overrides .env (--with-a2a on CLI wins over .env value)
  if [ "$A2A_ENABLED" != "true" ]; then
    A2A_ENABLED="${A2A_ENABLED:-false}"
  fi
  KEYCLOAK_URL="${KEYCLOAK_URL:-}"
  KEYCLOAK_REALM="${KEYCLOAK_REALM:-}"
  KEYCLOAK_ADMIN_USERNAME="${KEYCLOAK_ADMIN_USERNAME:-}"
  KEYCLOAK_ADMIN_PASSWORD="${KEYCLOAK_ADMIN_PASSWORD:-}"

  # If the gateway token is missing, the .env is corrupted — regenerate it
  if [ -z "$OPENCLAW_GATEWAY_TOKEN" ]; then
    log_warn ".env is missing OPENCLAW_GATEWAY_TOKEN — regenerating secrets"
    OPENCLAW_GATEWAY_TOKEN=$(generate_secret)
  fi
else
  log_info "Generating random secrets..."

  OPENCLAW_GATEWAY_TOKEN=$(generate_secret)

  if $K8S_MODE; then
    # K8s mode: no OAuth proxy, skip OAuth secrets
    OPENCLAW_OAUTH_CLIENT_SECRET=""
    OPENCLAW_OAUTH_COOKIE_SECRET=""
  else
    OPENCLAW_OAUTH_CLIENT_SECRET=$(generate_secret)
    OPENCLAW_OAUTH_COOKIE_SECRET=$(generate_cookie_secret)  # Must be 32 bytes for oauth-proxy
  fi

  log_success "Secrets generated"
  echo ""

  # Prompt for Anthropic API key (optional — for agents that use Anthropic models)
  log_info "Anthropic API key (optional, for agents using Claude models):"
  read -sp "  API key (leave empty to skip): " ANTHROPIC_API_KEY
  echo
  ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
  if [ -n "$ANTHROPIC_API_KEY" ]; then
    log_success "Anthropic API key set"
  else
    log_info "Skipped — agents will use in-cluster model only"
  fi
  echo ""

  # Prompt for model endpoint (OpenAI-compatible /v1 URL for in-cluster model)
  log_info "Model endpoint (OpenAI-compatible /v1 URL for in-cluster model):"
  log_info "  Default: http://vllm.openclaw-llms.svc.cluster.local/v1"
  log_info "  Options: deploy vLLM (see manifests/openclaw/llm/), use your own, or rely on Anthropic API"
  read -p "  Enter endpoint (or press Enter for default): " MODEL_ENDPOINT
  MODEL_ENDPOINT=${MODEL_ENDPOINT:-http://vllm.openclaw-llms.svc.cluster.local/v1}
  log_success "Model endpoint: $MODEL_ENDPOINT"
  echo ""

  # Prompt for Google Vertex AI (optional — for Gemini models via GCP)
  log_info "Google Vertex AI (optional, for Gemini models billed through GCP):"
  log_info "  Requires a GCP service account JSON key with Vertex AI permissions"
  read -p "  Enable Google Vertex? (y/N): " -n 1 -r VERTEX_REPLY
  echo
  if [[ "$VERTEX_REPLY" =~ ^[Yy]$ ]]; then
    read -p "  GCP project ID: " GOOGLE_CLOUD_PROJECT
    if [ -z "$GOOGLE_CLOUD_PROJECT" ]; then
      log_error "Project ID is required for Vertex AI"
      exit 1
    fi
    read -p "  Vertex provider — 'google' for Gemini, 'anthropic' for Claude [google]: " VERTEX_PROVIDER
    VERTEX_PROVIDER=${VERTEX_PROVIDER:-google}
    if [ "$VERTEX_PROVIDER" = "anthropic" ]; then
      REGION_DEFAULT="global"
    else
      REGION_DEFAULT="us-central1"
    fi
    read -p "  GCP region [$REGION_DEFAULT]: " GOOGLE_CLOUD_LOCATION
    GOOGLE_CLOUD_LOCATION=${GOOGLE_CLOUD_LOCATION:-$REGION_DEFAULT}
    read -p "  Path to service account JSON key (leave empty if secret already exists): " VERTEX_SA_JSON_PATH
    if [ -n "$VERTEX_SA_JSON_PATH" ] && [ ! -f "$VERTEX_SA_JSON_PATH" ]; then
      log_error "File not found: $VERTEX_SA_JSON_PATH"
      exit 1
    fi
    VERTEX_ENABLED=true
    if [ -z "$VERTEX_SA_JSON_PATH" ]; then
      log_info "No JSON key provided — assuming vertex secret already exists in cluster"
    fi
    log_success "Vertex AI enabled: project=$GOOGLE_CLOUD_PROJECT region=$GOOGLE_CLOUD_LOCATION"
  else
    VERTEX_ENABLED=false
    GOOGLE_CLOUD_PROJECT=""
    GOOGLE_CLOUD_LOCATION=""
    VERTEX_SA_JSON_PATH=""
    log_info "Skipped"
  fi
  echo ""

  # Prompt for Keycloak config (only when --with-a2a is set)
  if [ "$A2A_ENABLED" = "true" ]; then
    # Use values from .env.a2a if available, otherwise prompt
    if [ -n "${KEYCLOAK_URL:-}" ] && [ -n "${KEYCLOAK_ADMIN_PASSWORD:-}" ]; then
      log_info "Using Keycloak config from .env.a2a"
      KEYCLOAK_REALM="${KEYCLOAK_REALM:-spiffe-openclaw}"
      KEYCLOAK_ADMIN_USERNAME="${KEYCLOAK_ADMIN_USERNAME:-admin}"
      log_success "Keycloak: $KEYCLOAK_URL realm=$KEYCLOAK_REALM"
    else
      log_info "A2A AuthBridge requires a Keycloak instance for token exchange."
      log_info "(Tip: run manifests/a2a-infra/setup-a2a-infra.sh first to save these in .env.a2a)"
      read -p "  Keycloak URL (e.g., https://keycloak.apps.mycluster.com): " KEYCLOAK_URL
      if [ -z "$KEYCLOAK_URL" ]; then
        log_error "Keycloak URL is required for A2A AuthBridge"
        exit 1
      fi
      read -p "  Keycloak realm [spiffe-openclaw]: " KEYCLOAK_REALM
      KEYCLOAK_REALM=${KEYCLOAK_REALM:-spiffe-openclaw}
      read -p "  Keycloak admin username [admin]: " KEYCLOAK_ADMIN_USERNAME
      KEYCLOAK_ADMIN_USERNAME=${KEYCLOAK_ADMIN_USERNAME:-admin}
      read -sp "  Keycloak admin password: " KEYCLOAK_ADMIN_PASSWORD
      echo
      if [ -z "$KEYCLOAK_ADMIN_PASSWORD" ]; then
        log_error "Keycloak admin password is required"
        exit 1
      fi
      log_success "Keycloak: $KEYCLOAK_URL realm=$KEYCLOAK_REALM"
    fi
  else
    KEYCLOAK_URL=""
    KEYCLOAK_REALM=""
    KEYCLOAK_ADMIN_USERNAME=""
    KEYCLOAK_ADMIN_PASSWORD=""
  fi
  echo ""
fi

# Warn about old manifests-private/ directory
if [ -d "$REPO_ROOT/manifests-private" ]; then
  log_warn "Found old manifests-private/ directory."
  log_warn "This script no longer uses manifests-private/. You can safely delete it:"
  echo "    rm -rf $REPO_ROOT/manifests-private"
  echo ""
fi

# Default MLflow URI (may not have been set on fresh runs)
MLFLOW_TRACKING_URI="${MLFLOW_TRACKING_URI:-}"

# Write .env file
log_info "Writing .env file..."
cat > "$REPO_ROOT/.env" <<EOF
# Generated by setup.sh — NEVER commit
CLUSTER_DOMAIN=$CLUSTER_DOMAIN
OPENCLAW_PREFIX=$OPENCLAW_PREFIX
OPENCLAW_NAMESPACE=$OPENCLAW_NAMESPACE
OPENCLAW_GATEWAY_TOKEN=$OPENCLAW_GATEWAY_TOKEN
OPENCLAW_OAUTH_CLIENT_SECRET=$OPENCLAW_OAUTH_CLIENT_SECRET
OPENCLAW_OAUTH_COOKIE_SECRET=$OPENCLAW_OAUTH_COOKIE_SECRET
ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY
MODEL_ENDPOINT=$MODEL_ENDPOINT
VERTEX_ENABLED=$VERTEX_ENABLED
VERTEX_PROVIDER=${VERTEX_PROVIDER:-}
GOOGLE_CLOUD_PROJECT=$GOOGLE_CLOUD_PROJECT
GOOGLE_CLOUD_LOCATION=$GOOGLE_CLOUD_LOCATION
VERTEX_SA_JSON_PATH=$VERTEX_SA_JSON_PATH
SHADOWMAN_CUSTOM_NAME=$SHADOWMAN_CUSTOM_NAME
SHADOWMAN_DISPLAY_NAME=$SHADOWMAN_DISPLAY_NAME
MLFLOW_TRACKING_URI=$MLFLOW_TRACKING_URI
A2A_ENABLED=$A2A_ENABLED
KEYCLOAK_URL=$KEYCLOAK_URL
KEYCLOAK_REALM=$KEYCLOAK_REALM
KEYCLOAK_ADMIN_USERNAME=$KEYCLOAK_ADMIN_USERNAME
KEYCLOAK_ADMIN_PASSWORD=$KEYCLOAK_ADMIN_PASSWORD
EOF
log_success ".env file created at $REPO_ROOT/.env"
echo ""

# Source .env and run envsubst on all .envsubst templates
log_info "Running envsubst on templates..."
set -a
# shellcheck disable=SC1091
source "$REPO_ROOT/.env"
set +a

# Agent name (set during initial setup, customizable via setup-agents.sh)
export SHADOWMAN_CUSTOM_NAME="${SHADOWMAN_CUSTOM_NAME:-shadowman}"
export SHADOWMAN_DISPLAY_NAME="${SHADOWMAN_DISPLAY_NAME:-Shadowman}"

# Default model endpoint (for existing .env files that don't have it yet)
export MODEL_ENDPOINT="${MODEL_ENDPOINT:-http://vllm.openclaw-llms.svc.cluster.local/v1}"

# Vertex defaults (for existing .env files that don't have these yet)
export VERTEX_ENABLED="${VERTEX_ENABLED:-false}"
export GOOGLE_CLOUD_PROJECT="${GOOGLE_CLOUD_PROJECT:-}"
export GOOGLE_CLOUD_LOCATION="${GOOGLE_CLOUD_LOCATION:-}"

# Keycloak defaults (for A2A AuthBridge)
export KEYCLOAK_URL="${KEYCLOAK_URL:-}"
export KEYCLOAK_REALM="${KEYCLOAK_REALM:-}"
export KEYCLOAK_ADMIN_USERNAME="${KEYCLOAK_ADMIN_USERNAME:-}"
export KEYCLOAK_ADMIN_PASSWORD="${KEYCLOAK_ADMIN_PASSWORD:-}"

# Agent model priority: Anthropic API > Vertex (anthropic or google) > in-cluster
# VERTEX_PROVIDER controls which Vertex provider: "anthropic" or "google" (default)
export VERTEX_PROVIDER="${VERTEX_PROVIDER:-google}"
if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
  export DEFAULT_AGENT_MODEL="anthropic/claude-sonnet-4-5"
elif [ "${VERTEX_ENABLED:-}" = "true" ] && [ "${VERTEX_PROVIDER}" = "anthropic" ]; then
  export DEFAULT_AGENT_MODEL="anthropic-vertex/claude-sonnet-4-6"
  log_info "Using Anthropic Vertex (Claude via GCP) as default agent model"
elif [ "${VERTEX_ENABLED:-}" = "true" ]; then
  export DEFAULT_AGENT_MODEL="google-vertex/gemini-2.5-pro"
  log_info "Using Google Vertex (Gemini) as default agent model"
else
  export DEFAULT_AGENT_MODEL="nerc/openai/gpt-oss-20b"
  log_info "No Anthropic API key or Vertex — agents will use in-cluster model (${MODEL_ENDPOINT})"
fi

# Explicit variable list to protect {agentId} and other non-env placeholders
ENVSUBST_VARS='${CLUSTER_DOMAIN} ${OPENCLAW_PREFIX} ${OPENCLAW_NAMESPACE} ${OPENCLAW_GATEWAY_TOKEN} ${OPENCLAW_OAUTH_CLIENT_SECRET} ${OPENCLAW_OAUTH_COOKIE_SECRET} ${ANTHROPIC_API_KEY} ${SHADOWMAN_CUSTOM_NAME} ${SHADOWMAN_DISPLAY_NAME} ${MODEL_ENDPOINT} ${DEFAULT_AGENT_MODEL} ${GOOGLE_CLOUD_PROJECT} ${GOOGLE_CLOUD_LOCATION} ${KEYCLOAK_URL} ${KEYCLOAK_REALM} ${KEYCLOAK_ADMIN_USERNAME} ${KEYCLOAK_ADMIN_PASSWORD}'

for tpl in $(find "$REPO_ROOT/manifests" "$REPO_ROOT/observability" -name '*.envsubst'); do
  yaml="${tpl%.envsubst}"
  envsubst "$ENVSUBST_VARS" < "$tpl" > "$yaml"
  log_success "Generated $(basename "$yaml")"
done
echo ""

# Select overlay based on mode
if $K8S_MODE; then
  OPENCLAW_OVERLAY="$REPO_ROOT/manifests/openclaw/overlays/k8s"
else
  OPENCLAW_OVERLAY="$REPO_ROOT/manifests/openclaw/overlays/openshift"
fi

# Strip A2A containers/volumes/resources when --with-a2a is not set (default)
if [ "$A2A_ENABLED" != "true" ]; then
  log_info "A2A disabled (use --with-a2a to enable). Stripping A2A resources..."
  # Copy strip-a2a patch into overlay (kustomize requires patches within overlay dir)
  cp "$REPO_ROOT/manifests/openclaw/patches/strip-a2a.yaml" "$OPENCLAW_OVERLAY/strip-a2a.yaml"
  cat >> "$OPENCLAW_OVERLAY/kustomization.yaml" <<'STRIP_A2A'
  # A2A disabled — strip containers, volumes, and resources
  - path: strip-a2a.yaml
  - target:
      kind: ConfigMap
      name: a2a-bridge
    patch: |
      $patch: delete
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: a2a-bridge
  - target:
      kind: ConfigMap
      name: authbridge-environments
    patch: |
      $patch: delete
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: authbridge-environments
  - target:
      kind: ConfigMap
      name: authbridge-spiffe-helper-config
    patch: |
      $patch: delete
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: authbridge-spiffe-helper-config
  - target:
      kind: ConfigMap
      name: authbridge-envoy-config
    patch: |
      $patch: delete
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: authbridge-envoy-config
  - target:
      kind: Secret
      name: authbridge-proxy-config
    patch: |
      $patch: delete
      apiVersion: v1
      kind: Secret
      metadata:
        name: authbridge-proxy-config
STRIP_A2A
  log_success "A2A patches appended to kustomization.yaml"
else
  log_info "A2A enabled — deploying with A2A bridge + AuthBridge sidecars"
fi
echo ""

# Create namespace
log_info "Creating namespace..."
$KUBECTL create namespace "$OPENCLAW_NAMESPACE" --dry-run=client -o yaml | $KUBECTL apply -f - > /dev/null
if [ "$A2A_ENABLED" = "true" ]; then
  $KUBECTL label namespace "$OPENCLAW_NAMESPACE" kagenti-enabled=true --overwrite > /dev/null
fi
$KUBECTL annotate namespace "$OPENCLAW_NAMESPACE" \
  "openclaw.dev/owner=$OPENCLAW_PREFIX" \
  "openclaw.dev/agent-name=$SHADOWMAN_DISPLAY_NAME" \
  "openclaw.dev/agent-id=${OPENCLAW_PREFIX}_${SHADOWMAN_CUSTOM_NAME}" \
  --overwrite > /dev/null
log_success "Namespace created: $OPENCLAW_NAMESPACE (owner: $OPENCLAW_PREFIX, agent: $SHADOWMAN_DISPLAY_NAME)"
echo ""

# Create Vertex AI credentials secret (if enabled)
if [ "${VERTEX_ENABLED:-}" = "true" ] && [ -n "${VERTEX_SA_JSON_PATH:-}" ] && [ -f "${VERTEX_SA_JSON_PATH:-}" ]; then
  log_info "Creating Vertex AI credentials secret..."
  $KUBECTL create secret generic ambient-vertex \
    -n "$OPENCLAW_NAMESPACE" \
    --from-file=vertex-credentials.json="$VERTEX_SA_JSON_PATH" \
    --dry-run=client -o yaml | $KUBECTL apply -f -
  log_success "Vertex AI credentials secret created"
  echo ""
fi

if $K8S_MODE; then
  log_info "Skipping OAuthClient and SCC (not needed in Kubernetes mode)"
  echo ""
else
  # Deploy cluster-scoped resources separately (can't go through Kustomize namespace transformer)

  # SCC definition + RBAC grant (only needed for A2A AuthBridge sidecars)
  if [ "$A2A_ENABLED" = "true" ]; then
    log_info "Applying AuthBridge SCC and RBAC grant..."
    if oc apply -f "$REPO_ROOT/manifests/openclaw/base/openclaw-scc.yaml" 2>/dev/null && \
       oc apply -f "$OPENCLAW_OVERLAY/scc-rbac.yaml" 2>/dev/null; then
      log_success "SCC openclaw-authbridge applied and granted to openclaw-oauth-proxy"
    else
      log_warn "Could not apply SCC (requires cluster-admin permissions)"
      log_warn "Ask your cluster admin to run:"
      echo "    oc apply -f $REPO_ROOT/manifests/openclaw/base/openclaw-scc.yaml"
      echo "    oc apply -f $OPENCLAW_OVERLAY/scc-rbac.yaml"
    fi
  else
    log_info "Skipping AuthBridge SCC (A2A disabled)"
  fi

  # OAuthClient
  log_info "Creating OAuthClient..."
  if oc apply -f "$OPENCLAW_OVERLAY/oauthclient.yaml" 2>/dev/null; then
    log_success "OpenClaw OAuthClient created"
  else
    log_warn "Could not create OpenClaw OAuthClient (requires cluster-admin permissions)"
    log_warn "Ask your cluster admin to run:"
    echo "    oc apply -f $OPENCLAW_OVERLAY/oauthclient.yaml"
  fi
  echo ""
fi

# Deploy OpenClaw with Security Hardening
log_info "Deploying OpenClaw Gateway with security hardening..."
log_info "  ✓ ResourceQuota (namespace limits)"
log_info "  ✓ PodDisruptionBudget (HA)"
log_info "  ✓ Read-only filesystem"
log_info "  ✓ Health probes"
log_info "  ✓ Device authentication"
if [ "$A2A_ENABLED" = "true" ]; then
  log_info "  ✓ A2A bridge + AuthBridge sidecars"
else
  log_info "  ○ A2A disabled (use --with-a2a to enable)"
fi
$KUBECTL apply -k "$OPENCLAW_OVERLAY"
log_success "OpenClaw deployed with enterprise security"
echo ""

# Install A2A skill (only when A2A is enabled)
if [ "$A2A_ENABLED" = "true" ]; then
  log_info "Installing A2A skill..."
  SKILLS_DIR="$REPO_ROOT/manifests/openclaw/skills"
  $KUBECTL kustomize "$SKILLS_DIR" \
    | sed "s/namespace: openclaw/namespace: $OPENCLAW_NAMESPACE/g" \
    | $KUBECTL apply -f -
  log_success "A2A skill ConfigMap deployed"

  # Wait for pod to be ready before copying skill into workspace
  log_info "Waiting for OpenClaw pod to start..."
  if $KUBECTL rollout status deployment/openclaw -n "$OPENCLAW_NAMESPACE" --timeout=300s 2>/dev/null; then
    POD=$($KUBECTL get pods -n "$OPENCLAW_NAMESPACE" -l app=openclaw --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
    if [ -n "$POD" ]; then
      $KUBECTL get configmap a2a-skill -n "$OPENCLAW_NAMESPACE" -o jsonpath='{.data.SKILL\.md}' | \
        $KUBECTL exec -i -n "$OPENCLAW_NAMESPACE" "$POD" -c gateway -- \
          sh -c 'mkdir -p /home/node/.openclaw/skills/a2a && cat > /home/node/.openclaw/skills/a2a/SKILL.md'
      log_success "A2A skill installed into workspace"
    else
      log_warn "Could not find running pod — run install-a2a-skill.sh manually after pod starts"
    fi
  else
    log_warn "Pod not ready yet — run install-a2a-skill.sh manually after pod starts"
  fi
else
  log_info "Skipping A2A skill installation (A2A disabled)"
fi
echo ""

echo ""
echo "╔════════════════════════════════════════════════════════════╗"
echo "║  Deployment Complete!                                      ║"
echo "╚════════════════════════════════════════════════════════════╝"
echo ""

if $K8S_MODE; then
  echo "Access (use port-forward):"
  echo "  kubectl port-forward svc/openclaw 18789:18789 -n $OPENCLAW_NAMESPACE"
  echo ""
  echo "Then open:"
  echo "  OpenClaw Gateway:    http://localhost:18789"
  echo ""
else
  # Get routes
  log_info "Getting routes..."
  OPENCLAW_ROUTE=$(oc get route openclaw -n "$OPENCLAW_NAMESPACE" -o jsonpath='{.spec.host}' 2>/dev/null || echo "")

  echo "Access URLs:"
  echo "  OpenClaw Gateway:          https://${OPENCLAW_ROUTE}"
  echo ""
fi

echo "Credentials:"
echo "  OpenClaw Gateway Token: $OPENCLAW_GATEWAY_TOKEN"
echo ""

echo "Next steps — deploy AI agents:"
echo "  1. Wait for OpenClaw to be ready:"
echo "     $KUBECTL rollout status deployment/openclaw -n $OPENCLAW_NAMESPACE --timeout=600s"
echo "  2. Run the agent setup script:"
echo "     scripts/setup-agents.sh$(if $K8S_MODE; then echo ' --k8s'; fi)"
echo ""

log_success "Setup complete!"
echo ""
