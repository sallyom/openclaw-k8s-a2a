#!/usr/bin/env bash
# ============================================================================
# FIRST-TIME DEPLOYMENT SCRIPT
# ============================================================================
# TODO: Split this script into setup-platform.sh + setup-agent.sh in a future PR.
#       setup-platform.sh should deploy platform/base + platform/overlays/<target>
#       setup-agent.sh should deploy agents/<name>/overlays/<target>
#       This will decouple platform provisioning from agent-specific configuration.
# ============================================================================
# Use this for complete deployment of OpenClaw + Agents
#
# Usage:
#   ./setup.sh                    # Deploy to OpenShift (default, no A2A)
#   ./setup.sh --with-a2a         # Deploy with Kagenti AIB (webhook-injected sidecars)
#   ./setup.sh --k8s              # Deploy to vanilla Kubernetes (minikube, kind, etc.)
#   ./setup.sh --k8s --with-a2a   # K8s with A2A
#
# This script:
#   - Generates all secrets (gateway, OAuth) into .env
#   - Runs envsubst on committed .envsubst templates to produce deployment YAML
#   - Creates namespace (openclaw)
#   - Deploys OpenClaw gateway with security hardening:
#       * NetworkPolicy (network isolation)
#       * ResourceQuota (namespace limits: 4 CPU, 8Gi RAM)
#       * PodDisruptionBudget (high availability)
#       * Read-only root filesystem
#       * Health probes (liveness & readiness)
#       * Device authentication enabled
#       * Non-root containers with dropped capabilities
#   - Optionally deploys AI agents with RBAC
#   - Sets up cron jobs for autonomous tasks
#
# IMPORTANT:
#   - .envsubst templates are committed to Git (contain ${VAR} placeholders)
#   - .env file is generated by this script (real secrets) — NEVER commit!
#   - Generated .yaml files (from envsubst) are gitignored — NEVER commit!
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Parse flags
K8S_MODE=false
A2A_ENABLED=false
for arg in "$@"; do
  case "$arg" in
    --k8s) K8S_MODE=true ;;
    --with-a2a) A2A_ENABLED=true ;;
  esac
done

# CLI tool selection
if $K8S_MODE; then
  KUBECTL="kubectl"
else
  KUBECTL="oc"
fi

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
RED='\033[0;31m'
NC='\033[0m'

log_info() {
  echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
  echo -e "${GREEN}✅ $1${NC}"
}

log_warn() {
  echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
  echo -e "${RED}❌ $1${NC}"
}

# Apply a manifest with openclaw namespace replaced by $OPENCLAW_NAMESPACE
# Used for files applied directly (not through kustomize overlay)
apply_openclaw() {
  sed "s/namespace: openclaw/namespace: $OPENCLAW_NAMESPACE/g" "$1" | $KUBECTL apply -f -
}

# Generate random base64-encoded secret (OpenShift compatible)
generate_secret() {
  openssl rand -base64 32
}

# Generate 32-byte cookie secret (for oauth-proxy, must be exactly 16, 24, or 32 bytes)
generate_cookie_secret() {
  # Generate 32 random characters (32 bytes)
  # Use openssl instead of tr|head to avoid SIGPIPE exit under pipefail
  openssl rand -hex 16
}

echo ""
echo "╔════════════════════════════════════════════════════════════╗"
if $K8S_MODE; then
echo "║  OpenClaw Deployment Setup (Kubernetes mode)               ║"
else
echo "║  OpenClaw Deployment Setup (OpenShift mode)                ║"
fi
echo "╚════════════════════════════════════════════════════════════╝"
echo ""

# Check prerequisites
log_info "Checking prerequisites..."

if $K8S_MODE; then
  if ! command -v kubectl &> /dev/null; then
    log_error "kubectl CLI not found. Please install it first."
    exit 1
  fi

  if ! kubectl cluster-info &> /dev/null; then
    log_error "Cannot connect to Kubernetes cluster. Check your kubeconfig."
    exit 1
  fi

  CLUSTER_SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
  CLUSTER_USER=$(kubectl config view --minify -o jsonpath='{.contexts[0].context.user}')
  log_success "Connected to $CLUSTER_SERVER as $CLUSTER_USER"
  echo ""

  # K8s mode: no cluster domain needed (no routes)
  CLUSTER_DOMAIN=""
else
  if ! command -v oc &> /dev/null; then
    log_error "oc CLI not found. Please install it first."
    exit 1
  fi

  if ! oc whoami &> /dev/null; then
    log_error "Not logged in to OpenShift. Run 'oc login' first."
    exit 1
  fi

  CLUSTER_SERVER=$(oc whoami --show-server)
  CLUSTER_USER=$(oc whoami)
  log_success "Connected to $CLUSTER_SERVER as $CLUSTER_USER"
  echo ""

  # Get cluster domain
  log_info "Detecting cluster domain..."
  if CLUSTER_DOMAIN=$(oc get ingresses.config/cluster -o jsonpath='{.spec.domain}' 2>/dev/null); then
    log_success "Cluster domain: $CLUSTER_DOMAIN"
  else
    log_warn "Could not auto-detect cluster domain"
    read -p "Enter cluster domain (e.g., apps.mycluster.com): " CLUSTER_DOMAIN
  fi
  echo ""
fi

# Load existing .env early so we can skip prompts on re-runs
# Preserve CLI flags — .env sourcing must not overwrite them
_CLI_A2A_ENABLED="$A2A_ENABLED"
_CLI_K8S_MODE="$K8S_MODE"
_ENV_REUSE=false
if [ -f "$REPO_ROOT/.env" ]; then
  set -a
  # shellcheck disable=SC1091
  source "$REPO_ROOT/.env"
  set +a
  _ENV_REUSE=true
fi
# CLI flags always win over .env values
A2A_ENABLED="$_CLI_A2A_ENABLED"
K8S_MODE="$_CLI_K8S_MODE"

# Prompt for OpenClaw namespace prefix (skip if already set from local .env)
if $_ENV_REUSE && [ -n "${OPENCLAW_PREFIX:-}" ]; then
  OPENCLAW_NAMESPACE="${OPENCLAW_NAMESPACE:-${OPENCLAW_PREFIX}-openclaw}"
  SHADOWMAN_CUSTOM_NAME="${SHADOWMAN_CUSTOM_NAME:-shadowman}"
  SHADOWMAN_DISPLAY_NAME="${SHADOWMAN_DISPLAY_NAME:-Shadowman}"
  log_success "Re-run detected — using prefix '$OPENCLAW_PREFIX' from .env"
  log_success "  Namespace: $OPENCLAW_NAMESPACE"
  log_success "  Agent: ${SHADOWMAN_DISPLAY_NAME} (${OPENCLAW_PREFIX}_${SHADOWMAN_CUSTOM_NAME})"
  echo ""
else
  log_info "OpenClaw namespace (each team member gets their own):"
  log_info "  Format: <prefix>-openclaw (e.g., sally-openclaw, bob-openclaw)"
  echo ""
  while true; do
    read -p "  Enter your prefix: " OPENCLAW_PREFIX
    if [ -n "$OPENCLAW_PREFIX" ]; then
      break
    fi
    log_error "A prefix is required to make your OpenClaw instance unique."
    log_error "Each team member must use a different prefix (e.g., your name)."
  done
  OPENCLAW_NAMESPACE="${OPENCLAW_PREFIX}-openclaw"
  read -p "  Namespace [${OPENCLAW_NAMESPACE}]: " CUSTOM_NS
  if [ -n "$CUSTOM_NS" ]; then
    OPENCLAW_NAMESPACE="$CUSTOM_NS"
  fi
  log_success "OpenClaw namespace: $OPENCLAW_NAMESPACE"
  echo ""

  # Prompt for agent name
  log_info "Your default agent is 'Shadowman'. You can customize its name."
  log_info "  This is the agent other teammates will see when you communicate via A2A."
  read -p "  Enter a name (or press Enter to keep 'Shadowman'): " CUSTOM_NAME
  if [ -n "$CUSTOM_NAME" ]; then
    SHADOWMAN_DISPLAY_NAME="$CUSTOM_NAME"
    SHADOWMAN_CUSTOM_NAME=$(echo "$CUSTOM_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '_' | tr -cd 'a-z0-9_')
    log_success "Agent: '${SHADOWMAN_DISPLAY_NAME}' (id: ${OPENCLAW_PREFIX}_${SHADOWMAN_CUSTOM_NAME})"
  else
    SHADOWMAN_CUSTOM_NAME="shadowman"
    SHADOWMAN_DISPLAY_NAME="Shadowman"
    log_info "Keeping default name: Shadowman"
  fi
  echo ""
fi

# Confirm deployment
log_warn "This will deploy OpenClaw to namespace: $OPENCLAW_NAMESPACE"
log_warn "  Agent: ${SHADOWMAN_DISPLAY_NAME} (${OPENCLAW_PREFIX}_${SHADOWMAN_CUSTOM_NAME})"
read -p "Continue? (y/N): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  log_info "Deployment cancelled"
  exit 0
fi
echo ""

# Reuse secrets from .env or generate new ones
if $_ENV_REUSE; then
  log_info "Reusing secrets from .env (delete .env to regenerate)"
  log_success "Secrets loaded from .env"
  echo ""

  # Default any missing variables to empty
  OPENCLAW_GATEWAY_TOKEN="${OPENCLAW_GATEWAY_TOKEN:-}"
  OPENCLAW_OAUTH_CLIENT_SECRET="${OPENCLAW_OAUTH_CLIENT_SECRET:-}"
  OPENCLAW_OAUTH_COOKIE_SECRET="${OPENCLAW_OAUTH_COOKIE_SECRET:-}"
  ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-}"
  MODEL_ENDPOINT="${MODEL_ENDPOINT:-}"
  VERTEX_ENABLED="${VERTEX_ENABLED:-false}"
  GOOGLE_CLOUD_PROJECT="${GOOGLE_CLOUD_PROJECT:-}"
  GOOGLE_CLOUD_LOCATION="${GOOGLE_CLOUD_LOCATION:-}"
  VERTEX_SA_JSON_PATH="${VERTEX_SA_JSON_PATH:-}"
  MLFLOW_TRACKING_URI="${MLFLOW_TRACKING_URI:-}"
  # A2A_ENABLED already restored from CLI flag above

  # If the gateway token is missing, the .env is corrupted — regenerate it
  if [ -z "$OPENCLAW_GATEWAY_TOKEN" ]; then
    log_warn ".env is missing OPENCLAW_GATEWAY_TOKEN — regenerating secrets"
    OPENCLAW_GATEWAY_TOKEN=$(generate_secret)
  fi
else
  log_info "Generating random secrets..."

  OPENCLAW_GATEWAY_TOKEN=$(generate_secret)

  if $K8S_MODE; then
    # K8s mode: no OAuth proxy, skip OAuth secrets
    OPENCLAW_OAUTH_CLIENT_SECRET=""
    OPENCLAW_OAUTH_COOKIE_SECRET=""
  else
    OPENCLAW_OAUTH_CLIENT_SECRET=$(generate_secret)
    OPENCLAW_OAUTH_COOKIE_SECRET=$(generate_cookie_secret)  # Must be 32 bytes for oauth-proxy
  fi

  log_success "Secrets generated"
  echo ""

  # Prompt for Anthropic API key (optional — for agents that use Anthropic models)
  log_info "Anthropic API key (optional, for agents using Claude models):"
  read -sp "  API key (leave empty to skip): " ANTHROPIC_API_KEY
  echo
  ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
  if [ -n "$ANTHROPIC_API_KEY" ]; then
    log_success "Anthropic API key set"
  else
    log_info "Skipped — agents will use in-cluster model only"
  fi
  echo ""

  # Prompt for model endpoint (OpenAI-compatible /v1 URL for in-cluster model)
  log_info "Model endpoint (OpenAI-compatible /v1 URL for in-cluster model):"
  log_info "  Default: http://vllm.openclaw-llms.svc.cluster.local/v1"
  log_info "  Options: deploy vLLM (see agents/openclaw/llm/), use your own, or rely on Anthropic API"
  read -p "  Enter endpoint (or press Enter for default): " MODEL_ENDPOINT
  MODEL_ENDPOINT=${MODEL_ENDPOINT:-http://vllm.openclaw-llms.svc.cluster.local/v1}
  log_success "Model endpoint: $MODEL_ENDPOINT"
  echo ""

  # Prompt for Google Vertex AI (optional — for Gemini models via GCP)
  log_info "Google Vertex AI (optional, for Gemini models billed through GCP):"
  log_info "  Requires a GCP service account JSON key with Vertex AI permissions"
  read -p "  Enable Google Vertex? (y/N): " -n 1 -r VERTEX_REPLY
  echo
  if [[ "$VERTEX_REPLY" =~ ^[Yy]$ ]]; then
    read -p "  GCP project ID: " GOOGLE_CLOUD_PROJECT
    if [ -z "$GOOGLE_CLOUD_PROJECT" ]; then
      log_error "Project ID is required for Vertex AI"
      exit 1
    fi
    read -p "  Vertex provider — 'google' for Gemini, 'anthropic' for Claude [google]: " VERTEX_PROVIDER
    VERTEX_PROVIDER=${VERTEX_PROVIDER:-google}
    if [ "$VERTEX_PROVIDER" = "anthropic" ]; then
      REGION_DEFAULT="global"
    else
      REGION_DEFAULT="us-central1"
    fi
    read -p "  GCP region [$REGION_DEFAULT]: " GOOGLE_CLOUD_LOCATION
    GOOGLE_CLOUD_LOCATION=${GOOGLE_CLOUD_LOCATION:-$REGION_DEFAULT}
    read -p "  Path to service account JSON key (leave empty if secret already exists): " VERTEX_SA_JSON_PATH
    if [ -n "$VERTEX_SA_JSON_PATH" ] && [ ! -f "$VERTEX_SA_JSON_PATH" ]; then
      log_error "File not found: $VERTEX_SA_JSON_PATH"
      exit 1
    fi
    VERTEX_ENABLED=true
    if [ -z "$VERTEX_SA_JSON_PATH" ]; then
      log_info "No JSON key provided — assuming vertex secret already exists in cluster"
    fi
    log_success "Vertex AI enabled: project=$GOOGLE_CLOUD_PROJECT region=$GOOGLE_CLOUD_LOCATION"
  else
    VERTEX_ENABLED=false
    VERTEX_PROVIDER=""
    GOOGLE_CLOUD_PROJECT=""
    GOOGLE_CLOUD_LOCATION=""
    VERTEX_SA_JSON_PATH=""
    log_info "Skipped"
  fi
  echo ""

  # Prompt for Telegram bot token (optional)
  log_info "Telegram bot (optional, for messaging your agent via Telegram):"
  log_info "  Create a bot via @BotFather on Telegram to get a token"
  read -p "  Telegram bot token (or press Enter to skip): " TELEGRAM_BOT_TOKEN
  if [ -n "$TELEGRAM_BOT_TOKEN" ]; then
    TELEGRAM_ENABLED=true
    log_info "  DM allowlist: only these Telegram user IDs can message the bot"
    log_info "  Find your ID by messaging @userinfobot on Telegram"
    read -p "  Allowed user IDs (comma-separated, e.g. 123456789): " TELEGRAM_ALLOW_FROM
    if [ -z "$TELEGRAM_ALLOW_FROM" ]; then
      log_warn "No user IDs provided — bot will reject all DMs until allowFrom is configured"
    fi
    log_success "Telegram enabled"
  else
    TELEGRAM_ENABLED=false
    TELEGRAM_BOT_TOKEN=""
    TELEGRAM_ALLOW_FROM=""
    log_info "Skipped"
  fi
  echo ""

  # Prompt for MLflow tracking URI (optional — for observability / mlops-monitor agent)
  log_info "MLflow tracking URI (optional, for trace observability and mlops-monitor agent):"
  log_info "  Example: https://mlflow-openclaw.apps.example.com"
  read -p "  MLflow URI (or press Enter to skip): " MLFLOW_TRACKING_URI
  MLFLOW_TRACKING_URI=${MLFLOW_TRACKING_URI:-}
  if [ -n "$MLFLOW_TRACKING_URI" ]; then
    log_success "MLflow URI: $MLFLOW_TRACKING_URI"
  else
    log_info "Skipped — mlops-monitor will need this configured later via setup-agents.sh"
  fi
  echo ""

fi

# Warn about old manifests-private/ directory
if [ -d "$REPO_ROOT/manifests-private" ]; then
  log_warn "Found old manifests-private/ directory."
  log_warn "This script no longer uses manifests-private/. You can safely delete it:"
  echo "    rm -rf $REPO_ROOT/manifests-private"
  echo ""
fi

# Write .env file
log_info "Writing .env file..."
cat > "$REPO_ROOT/.env" <<EOF
# Generated by setup.sh — NEVER commit
CLUSTER_DOMAIN=$CLUSTER_DOMAIN
OPENCLAW_PREFIX=$OPENCLAW_PREFIX
OPENCLAW_NAMESPACE=$OPENCLAW_NAMESPACE
OPENCLAW_GATEWAY_TOKEN=$OPENCLAW_GATEWAY_TOKEN
OPENCLAW_OAUTH_CLIENT_SECRET=$OPENCLAW_OAUTH_CLIENT_SECRET
OPENCLAW_OAUTH_COOKIE_SECRET=$OPENCLAW_OAUTH_COOKIE_SECRET
ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY
MODEL_ENDPOINT=$MODEL_ENDPOINT
VERTEX_ENABLED=$VERTEX_ENABLED
VERTEX_PROVIDER=$VERTEX_PROVIDER
GOOGLE_CLOUD_PROJECT=$GOOGLE_CLOUD_PROJECT
GOOGLE_CLOUD_LOCATION=$GOOGLE_CLOUD_LOCATION
VERTEX_SA_JSON_PATH=$VERTEX_SA_JSON_PATH
SHADOWMAN_CUSTOM_NAME=$SHADOWMAN_CUSTOM_NAME
SHADOWMAN_DISPLAY_NAME=$SHADOWMAN_DISPLAY_NAME
TELEGRAM_BOT_TOKEN=$TELEGRAM_BOT_TOKEN
TELEGRAM_ENABLED=$TELEGRAM_ENABLED
TELEGRAM_ALLOW_FROM=$TELEGRAM_ALLOW_FROM
MLFLOW_TRACKING_URI=$MLFLOW_TRACKING_URI
A2A_ENABLED=$A2A_ENABLED
EOF
log_success ".env file created at $REPO_ROOT/.env"
echo ""

# Source .env and run envsubst on all .envsubst templates
log_info "Running envsubst on templates..."
set -a
# shellcheck disable=SC1091
source "$REPO_ROOT/.env"
set +a

# Agent name (set during initial setup, customizable via setup-agents.sh)
export SHADOWMAN_CUSTOM_NAME="${SHADOWMAN_CUSTOM_NAME:-shadowman}"
export SHADOWMAN_DISPLAY_NAME="${SHADOWMAN_DISPLAY_NAME:-Shadowman}"

# Default model endpoint (for existing .env files that don't have it yet)
export MODEL_ENDPOINT="${MODEL_ENDPOINT:-http://vllm.openclaw-llms.svc.cluster.local/v1}"

# Vertex defaults (for existing .env files that don't have these yet)
export VERTEX_ENABLED="${VERTEX_ENABLED:-false}"
export GOOGLE_CLOUD_PROJECT="${GOOGLE_CLOUD_PROJECT:-}"
export GOOGLE_CLOUD_LOCATION="${GOOGLE_CLOUD_LOCATION:-}"

# Telegram defaults (for existing .env files that don't have these yet)
export TELEGRAM_BOT_TOKEN="${TELEGRAM_BOT_TOKEN:-}"
export TELEGRAM_ENABLED="${TELEGRAM_ENABLED:-false}"
export TELEGRAM_ALLOW_FROM="${TELEGRAM_ALLOW_FROM:-}"

# Agent model priority: Anthropic API > Vertex (anthropic or google) > in-cluster
# VERTEX_PROVIDER controls which Vertex provider: "anthropic" or "google" (default)
export VERTEX_PROVIDER="${VERTEX_PROVIDER:-google}"
if [ -n "${ANTHROPIC_API_KEY:-}" ]; then
  export DEFAULT_AGENT_MODEL="anthropic/claude-sonnet-4-5"
elif [ "${VERTEX_ENABLED:-}" = "true" ] && [ "${VERTEX_PROVIDER}" = "anthropic" ]; then
  # TODO: upgrade to "anthropic-vertex/claude-sonnet-4-6" when SA has access to 4.6 models
  export DEFAULT_AGENT_MODEL="anthropic-vertex/claude-sonnet-4-5@20250929"
  log_info "Using Anthropic Vertex (Claude via GCP) as default agent model"
elif [ "${VERTEX_ENABLED:-}" = "true" ]; then
  export DEFAULT_AGENT_MODEL="google-vertex/gemini-2.5-pro"
  log_info "Using Google Vertex (Gemini) as default agent model"
else
  export DEFAULT_AGENT_MODEL="nerc/openai/gpt-oss-20b"
  log_info "No Anthropic API key or Vertex — agents will use in-cluster model (${MODEL_ENDPOINT})"
fi

# Explicit variable list to protect {agentId} and other non-env placeholders
ENVSUBST_VARS='${CLUSTER_DOMAIN} ${OPENCLAW_PREFIX} ${OPENCLAW_NAMESPACE} ${OPENCLAW_GATEWAY_TOKEN} ${OPENCLAW_OAUTH_CLIENT_SECRET} ${OPENCLAW_OAUTH_COOKIE_SECRET} ${ANTHROPIC_API_KEY} ${SHADOWMAN_CUSTOM_NAME} ${SHADOWMAN_DISPLAY_NAME} ${MODEL_ENDPOINT} ${DEFAULT_AGENT_MODEL} ${GOOGLE_CLOUD_PROJECT} ${GOOGLE_CLOUD_LOCATION} ${TELEGRAM_ALLOW_FROM}'

for tpl in $(find "$REPO_ROOT/agents" "$REPO_ROOT/platform" "$REPO_ROOT/manifests" -name '*.envsubst'); do
  yaml="${tpl%.envsubst}"
  envsubst "$ENVSUBST_VARS" < "$tpl" > "$yaml"
  log_success "Generated $(basename "$yaml")"
done
echo ""

# Strip Telegram channel config when disabled (empty allowFrom fails validation)
if [ "${TELEGRAM_ENABLED:-false}" != "true" ]; then
  for cfg in "$REPO_ROOT/agents/openclaw/overlays"/*/config-patch.yaml; do
    if [ -f "$cfg" ]; then
      python3 -c "
import json, sys
with open('$cfg') as f:
    lines = f.readlines()
# Find the JSON blob inside the YAML (between the first { and last })
json_start = next(i for i, l in enumerate(lines) if l.strip().startswith('{'))
json_end = next(i for i in range(len(lines)-1, -1, -1) if lines[i].strip().startswith('}'))
prefix = lines[:json_start]
suffix = lines[json_end+1:]
blob = json.loads(''.join(lines[json_start:json_end+1]))
blob.pop('channels', None)
blob.get('settings', {}).pop('channels', None)
indent = len(lines[json_start]) - len(lines[json_start].lstrip())
formatted = json.dumps(blob, indent=2)
# Re-indent to match YAML nesting
indented = '\n'.join(' ' * indent + l for l in formatted.splitlines()) + '\n'
with open('$cfg', 'w') as f:
    f.writelines(prefix + [indented] + suffix)
" 2>/dev/null && log_success "Stripped Telegram config (disabled)" || true
    fi
  done
fi

# Select overlay based on mode
if $K8S_MODE; then
  OPENCLAW_OVERLAY="$REPO_ROOT/agents/openclaw/overlays/k8s"
else
  OPENCLAW_OVERLAY="$REPO_ROOT/agents/openclaw/overlays/openshift"
fi

# A2A sidecars are injected by the Kagenti webhook when kagenti.io/inject=enabled
# (set in the base deployment). Port exclusions are controlled via pod annotations
# (kagenti.io/outbound-ports-exclude, kagenti.io/inbound-ports-exclude).
# When A2A is disabled, we patch the inject label to disabled and remove AgentCard + SCC.
if [ "$A2A_ENABLED" != "true" ]; then
  log_info "A2A disabled (use --with-a2a to enable). Setting kagenti.io/inject=disabled..."
  cat >> "$OPENCLAW_OVERLAY/kustomization.yaml" <<'DISABLE_AIB'
  # A2A disabled — set inject label to disabled and remove AgentCard + SCC
  - target:
      kind: Deployment
      name: openclaw
    patch: |
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: openclaw
      spec:
        template:
          metadata:
            labels:
              kagenti.io/inject: disabled
  - target:
      kind: AgentCard
      name: openclaw-agent-card
    patch: |
      $patch: delete
      apiVersion: agent.kagenti.dev/v1alpha1
      kind: AgentCard
      metadata:
        name: openclaw-agent-card
  - target:
      kind: SecurityContextConstraints
      name: openclaw-authbridge
    patch: |
      $patch: delete
      apiVersion: security.openshift.io/v1
      kind: SecurityContextConstraints
      metadata:
        name: openclaw-authbridge
DISABLE_AIB
  log_success "A2A disabled — webhook injection disabled, AgentCard and SCC removed"
else
  log_info "A2A enabled — Kagenti webhook will inject AIB sidecars at admission time"
fi
echo ""

# Create namespace
log_info "Creating namespace..."
$KUBECTL create namespace "$OPENCLAW_NAMESPACE" --dry-run=client -o yaml | $KUBECTL apply -f - > /dev/null
# The kagenti-enabled label is set by setup-kagenti.sh (via agentNamespaces in helm values).
# It triggers Kagenti to create AuthBridge ConfigMaps in the namespace and enables
# webhook injection for pods with kagenti.io/inject=enabled.
$KUBECTL annotate namespace "$OPENCLAW_NAMESPACE" \
  "openclaw.dev/owner=$OPENCLAW_PREFIX" \
  "openclaw.dev/agent-name=$SHADOWMAN_DISPLAY_NAME" \
  "openclaw.dev/agent-id=${OPENCLAW_PREFIX}_${SHADOWMAN_CUSTOM_NAME}" \
  --overwrite > /dev/null
log_success "Namespace created: $OPENCLAW_NAMESPACE (owner: $OPENCLAW_PREFIX, agent: $SHADOWMAN_DISPLAY_NAME)"
echo ""

# Create Vertex AI credentials secret (if enabled)
if [ "${VERTEX_ENABLED:-}" = "true" ] && [ -n "${VERTEX_SA_JSON_PATH:-}" ] && [ -f "${VERTEX_SA_JSON_PATH:-}" ]; then
  log_info "Creating Vertex AI credentials secret..."
  $KUBECTL create secret generic ambient-vertex \
    -n "$OPENCLAW_NAMESPACE" \
    --from-file=vertex-credentials.json="$VERTEX_SA_JSON_PATH" \
    --dry-run=client -o yaml | $KUBECTL apply -f -
  log_success "Vertex AI credentials secret created"
  echo ""
fi

# Create Telegram bot secret (if enabled)
if [ "${TELEGRAM_ENABLED:-}" = "true" ] && [ -n "${TELEGRAM_BOT_TOKEN:-}" ]; then
  log_info "Creating Telegram bot secret..."
  $KUBECTL create secret generic telegram-secrets \
    -n "$OPENCLAW_NAMESPACE" \
    --from-literal=bot-token="$TELEGRAM_BOT_TOKEN" \
    --dry-run=client -o yaml | $KUBECTL apply -f -
  log_success "Telegram bot secret created"
  echo ""
fi

if $K8S_MODE; then
  log_info "Skipping OAuthClient and SCC (not needed in Kubernetes mode)"
  echo ""
else
  # Deploy cluster-scoped resources separately (can't go through Kustomize namespace transformer)

  # SCC definition + RBAC grant (only needed for A2A AuthBridge sidecars)
  if [ "$A2A_ENABLED" = "true" ]; then
    log_info "Applying AuthBridge SCC and RBAC grant..."
    if oc apply -f "$REPO_ROOT/platform/auth-identity-bridge/openclaw-scc.yaml" 2>/dev/null && \
       oc apply -f "$REPO_ROOT/platform/overlays/openshift/scc-rbac.yaml" 2>/dev/null; then
      log_success "SCC openclaw-authbridge applied and granted to openclaw-oauth-proxy"
    else
      log_warn "Could not apply SCC (requires cluster-admin permissions)"
      log_warn "Ask your cluster admin to run:"
      echo "    oc apply -f $REPO_ROOT/platform/auth-identity-bridge/openclaw-scc.yaml"
      echo "    oc apply -f $REPO_ROOT/platform/overlays/openshift/scc-rbac.yaml"
    fi
  else
    log_info "Skipping AuthBridge SCC (A2A disabled)"
  fi

  # OAuthClient
  log_info "Creating OAuthClient..."
  if oc apply -f "$REPO_ROOT/platform/overlays/openshift/oauthclient.yaml" 2>/dev/null; then
    log_success "OpenClaw OAuthClient created"
  else
    log_warn "Could not create OpenClaw OAuthClient (requires cluster-admin permissions)"
    log_warn "Ask your cluster admin to run:"
    echo "    oc apply -f $REPO_ROOT/platform/overlays/openshift/oauthclient.yaml"
  fi
  echo ""
fi

# Deploy OpenClaw with Security Hardening
log_info "Deploying OpenClaw Gateway with security hardening..."
log_info "  ✓ ResourceQuota (namespace limits)"
log_info "  ✓ PodDisruptionBudget (HA)"
log_info "  ✓ Read-only filesystem"
log_info "  ✓ Health probes"
log_info "  ✓ Device authentication"
if [ "$A2A_ENABLED" = "true" ]; then
  log_info "  ✓ Kagenti AIB (webhook-injected with port exclusion annotations)"
else
  log_info "  ○ Kagenti AIB disabled (use --with-a2a to enable)"
fi
$KUBECTL apply -k "$OPENCLAW_OVERLAY"
log_success "OpenClaw deployed with enterprise security"

echo ""

# Install A2A skill (only when A2A is enabled)
if [ "$A2A_ENABLED" = "true" ]; then
  log_info "Installing A2A skill..."
  SKILLS_DIR="$REPO_ROOT/agents/openclaw/skills"
  $KUBECTL kustomize "$SKILLS_DIR" \
    | sed "s/namespace: openclaw/namespace: $OPENCLAW_NAMESPACE/g" \
    | $KUBECTL apply -f -
  log_success "A2A skill ConfigMap deployed"

  # Wait for pod to be ready before copying skill into workspace
  log_info "Waiting for OpenClaw pod to start..."
  if $KUBECTL rollout status deployment/openclaw -n "$OPENCLAW_NAMESPACE" --timeout=300s 2>/dev/null; then
    POD=$($KUBECTL get pods -n "$OPENCLAW_NAMESPACE" -l app=openclaw --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
    if [ -n "$POD" ]; then
      $KUBECTL get configmap a2a-skill -n "$OPENCLAW_NAMESPACE" -o jsonpath='{.data.SKILL\.md}' | \
        $KUBECTL exec -i -n "$OPENCLAW_NAMESPACE" "$POD" -c gateway -- \
          sh -c 'mkdir -p /home/node/.openclaw/skills/a2a && cat > /home/node/.openclaw/skills/a2a/SKILL.md'
      log_success "A2A skill installed into workspace"
    else
      log_warn "Could not find running pod — run install-a2a-skill.sh manually after pod starts"
    fi
  else
    log_warn "Pod not ready yet — run install-a2a-skill.sh manually after pod starts"
  fi
else
  log_info "Skipping A2A skill installation (A2A disabled)"
fi
echo ""

echo ""
echo "╔════════════════════════════════════════════════════════════╗"
echo "║  Deployment Complete!                                      ║"
echo "╚════════════════════════════════════════════════════════════╝"
echo ""

if $K8S_MODE; then
  echo "Access (use port-forward):"
  echo "  kubectl port-forward svc/openclaw 18789:18789 -n $OPENCLAW_NAMESPACE"
  echo ""
  echo "Then open:"
  echo "  OpenClaw Gateway:    http://localhost:18789"
  echo ""
else
  # Get routes
  log_info "Getting routes..."
  OPENCLAW_ROUTE=$(oc get route openclaw -n "$OPENCLAW_NAMESPACE" -o jsonpath='{.spec.host}' 2>/dev/null || echo "")

  echo "Access URLs:"
  echo "  OpenClaw Gateway:          https://${OPENCLAW_ROUTE}"
  echo ""
fi

echo "Credentials:"
echo "  OpenClaw Gateway Token: $OPENCLAW_GATEWAY_TOKEN"
echo ""

echo "Next steps — deploy AI agents:"
echo "  1. Wait for OpenClaw to be ready:"
echo "     $KUBECTL rollout status deployment/openclaw -n $OPENCLAW_NAMESPACE --timeout=600s"
echo "  2. Run the agent setup script:"
echo "     scripts/setup-agents.sh$(if $K8S_MODE; then echo ' --k8s'; fi)"
echo ""

log_success "Setup complete!"
echo ""
