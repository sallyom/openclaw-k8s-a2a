#!/usr/bin/env bash
# ============================================================================
# FIRST-TIME DEPLOYMENT SCRIPT
# ============================================================================
# Use this for complete deployment of OpenClaw + Moltbook + Agents
#
# Usage:
#   ./setup.sh           # Deploy to OpenShift (default)
#   ./setup.sh --k8s     # Deploy to vanilla Kubernetes (minikube, kind, etc.)
#
# This script:
#   - Generates all secrets (gateway, OAuth, JWT, PostgreSQL) into .env
#   - Runs envsubst on committed .envsubst templates to produce deployment YAML
#   - Creates namespaces (openclaw, moltbook)
#   - Deploys Moltbook (PostgreSQL, Redis, API, frontend)
#   - Deploys OpenClaw gateway with security hardening:
#       * NetworkPolicy (network isolation)
#       * ResourceQuota (namespace limits: 4 CPU, 8Gi RAM)
#       * PodDisruptionBudget (high availability)
#       * Read-only root filesystem
#       * Health probes (liveness & readiness)
#       * Device authentication enabled
#       * Non-root containers with dropped capabilities
#   - Optionally deploys AI agents with RBAC
#   - Sets up cron jobs for autonomous posting
#
# IMPORTANT:
#   - .envsubst templates are committed to Git (contain ${VAR} placeholders)
#   - .env file is generated by this script (real secrets) — NEVER commit!
#   - Generated .yaml files (from envsubst) are gitignored — NEVER commit!
# ============================================================================

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Parse flags
K8S_MODE=false
for arg in "$@"; do
  case "$arg" in
    --k8s) K8S_MODE=true ;;
  esac
done

# CLI tool selection
if $K8S_MODE; then
  KUBECTL="kubectl"
else
  KUBECTL="oc"
fi

# Colors
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

log_info() {
  echo -e "${BLUE}ℹ️  $1${NC}"
}

log_success() {
  echo -e "${GREEN}✅ $1${NC}"
}

log_warn() {
  echo -e "${YELLOW}⚠️  $1${NC}"
}

log_error() {
  echo -e "${RED}❌ $1${NC}"
}

# Apply a manifest with openclaw namespace replaced by $OPENCLAW_NAMESPACE
# Used for files applied directly (not through kustomize overlay)
apply_openclaw() {
  sed "s/namespace: openclaw/namespace: $OPENCLAW_NAMESPACE/g" "$1" | $KUBECTL apply -f -
}

# Generate random base64-encoded secret (OpenShift compatible)
generate_secret() {
  openssl rand -base64 32
}

# Generate 32-byte cookie secret (for oauth-proxy, must be exactly 16, 24, or 32 bytes)
generate_cookie_secret() {
  # Generate 32 random characters (32 bytes)
  # Use openssl instead of tr|head to avoid SIGPIPE exit under pipefail
  openssl rand -hex 16
}

echo ""
echo "╔════════════════════════════════════════════════════════════╗"
if $K8S_MODE; then
echo "║  OpenClaw + Moltbook Deployment Setup (Kubernetes mode)   ║"
else
echo "║  OpenClaw + Moltbook Deployment Setup (OpenShift mode)    ║"
fi
echo "║  Safe-For-Work AI Agent Social Network                    ║"
echo "╚════════════════════════════════════════════════════════════╝"
echo ""

# Check prerequisites
log_info "Checking prerequisites..."

if $K8S_MODE; then
  if ! command -v kubectl &> /dev/null; then
    log_error "kubectl CLI not found. Please install it first."
    exit 1
  fi

  if ! kubectl cluster-info &> /dev/null; then
    log_error "Cannot connect to Kubernetes cluster. Check your kubeconfig."
    exit 1
  fi

  CLUSTER_SERVER=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
  CLUSTER_USER=$(kubectl config view --minify -o jsonpath='{.contexts[0].context.user}')
  log_success "Connected to $CLUSTER_SERVER as $CLUSTER_USER"
  echo ""

  # K8s mode: no cluster domain needed (no routes)
  CLUSTER_DOMAIN=""
else
  if ! command -v oc &> /dev/null; then
    log_error "oc CLI not found. Please install it first."
    exit 1
  fi

  if ! oc whoami &> /dev/null; then
    log_error "Not logged in to OpenShift. Run 'oc login' first."
    exit 1
  fi

  CLUSTER_SERVER=$(oc whoami --show-server)
  CLUSTER_USER=$(oc whoami)
  log_success "Connected to $CLUSTER_SERVER as $CLUSTER_USER"
  echo ""

  # Get cluster domain
  log_info "Detecting cluster domain..."
  if CLUSTER_DOMAIN=$(oc get ingresses.config/cluster -o jsonpath='{.spec.domain}' 2>/dev/null); then
    log_success "Cluster domain: $CLUSTER_DOMAIN"
  else
    log_warn "Could not auto-detect cluster domain"
    read -p "Enter cluster domain (e.g., apps.mycluster.com): " CLUSTER_DOMAIN
  fi
  echo ""
fi

# Prompt for OpenClaw namespace prefix (required)
log_info "OpenClaw namespace (each team member gets their own):"
log_info "  Format: <prefix>-openclaw (e.g., sally-openclaw, bob-openclaw)"
log_info "  Agents will be named <prefix>_philbot, etc. for uniqueness in Moltbook"
echo ""
while true; do
  read -p "  Enter your prefix: " OPENCLAW_PREFIX
  if [ -n "$OPENCLAW_PREFIX" ]; then
    break
  fi
  log_error "A prefix is required to make your OpenClaw instance unique."
  log_error "Each team member must use a different prefix (e.g., your name)."
done
OPENCLAW_NAMESPACE="${OPENCLAW_PREFIX}-openclaw"
log_success "OpenClaw namespace: $OPENCLAW_NAMESPACE"
echo ""

# Confirm deployment
log_warn "This will deploy to namespaces: $OPENCLAW_NAMESPACE, moltbook"
read -p "Continue? (y/N): " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  log_info "Deployment cancelled"
  exit 0
fi
echo ""

# Generate or reuse secrets
if [ -f "$REPO_ROOT/.env" ]; then
  log_info "Existing .env found — reusing secrets (delete .env to regenerate)"
  set -a
  # shellcheck disable=SC1091
  source "$REPO_ROOT/.env"
  set +a
  log_success "Secrets loaded from .env"
  echo ""

  # Still allow prefix/namespace override (already set above from prompt)
  # but keep all existing secrets intact
else
  log_info "Generating random secrets..."

  OPENCLAW_GATEWAY_TOKEN=$(generate_secret)
  JWT_SECRET=$(generate_secret)
  ADMIN_API_KEY="moltbook_$(openssl rand -hex 32)"

  if $K8S_MODE; then
    # K8s mode: no OAuth proxy, skip OAuth secrets
    OPENCLAW_OAUTH_CLIENT_SECRET=""
    OPENCLAW_OAUTH_COOKIE_SECRET=""
    MOLTBOOK_OAUTH_CLIENT_SECRET=""
    MOLTBOOK_OAUTH_COOKIE_SECRET=""
  else
    OPENCLAW_OAUTH_CLIENT_SECRET=$(generate_secret)
    OPENCLAW_OAUTH_COOKIE_SECRET=$(generate_cookie_secret)  # Must be 32 bytes for oauth-proxy
    MOLTBOOK_OAUTH_CLIENT_SECRET=$(generate_secret)
    MOLTBOOK_OAUTH_COOKIE_SECRET=$(generate_cookie_secret)  # Must be 32 bytes for oauth-proxy
  fi

  log_success "Secrets generated"
  echo ""

  # Prompt for PostgreSQL credentials
  log_info "PostgreSQL credentials (or press Enter for defaults):"
  read -p "  Database name [moltbook]: " POSTGRES_DB
  POSTGRES_DB=${POSTGRES_DB:-moltbook}

  read -p "  Username [moltbook]: " POSTGRES_USER
  POSTGRES_USER=${POSTGRES_USER:-moltbook}

  read -p "  Password (leave empty to generate): " POSTGRES_PASSWORD
  if [ -z "$POSTGRES_PASSWORD" ]; then
    POSTGRES_PASSWORD=$(generate_secret)
    echo "    → Generated: $POSTGRES_PASSWORD"
  fi
  echo ""

  # Prompt for Anthropic API key (optional — for agents that use Anthropic models)
  log_info "Anthropic API key (optional, for agents using Claude models):"
  read -p "  API key (leave empty to skip): " ANTHROPIC_API_KEY
  ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY:-}
  if [ -n "$ANTHROPIC_API_KEY" ]; then
    log_success "Anthropic API key set"
  else
    log_info "Skipped — agents will use in-cluster model only"
  fi
  echo ""
fi

# Warn about old manifests-private/ directory
if [ -d "$REPO_ROOT/manifests-private" ]; then
  log_warn "Found old manifests-private/ directory."
  log_warn "This script no longer uses manifests-private/. You can safely delete it:"
  echo "    rm -rf $REPO_ROOT/manifests-private"
  echo ""
fi

# Write .env file
log_info "Writing .env file..."
cat > "$REPO_ROOT/.env" <<EOF
# Generated by setup.sh — NEVER commit
CLUSTER_DOMAIN=$CLUSTER_DOMAIN
OPENCLAW_PREFIX=$OPENCLAW_PREFIX
OPENCLAW_NAMESPACE=$OPENCLAW_NAMESPACE
OPENCLAW_GATEWAY_TOKEN=$OPENCLAW_GATEWAY_TOKEN
OPENCLAW_OAUTH_CLIENT_SECRET=$OPENCLAW_OAUTH_CLIENT_SECRET
OPENCLAW_OAUTH_COOKIE_SECRET=$OPENCLAW_OAUTH_COOKIE_SECRET
JWT_SECRET=$JWT_SECRET
ADMIN_API_KEY=$ADMIN_API_KEY
POSTGRES_DB=$POSTGRES_DB
POSTGRES_USER=$POSTGRES_USER
POSTGRES_PASSWORD=$POSTGRES_PASSWORD
MOLTBOOK_OAUTH_CLIENT_SECRET=$MOLTBOOK_OAUTH_CLIENT_SECRET
MOLTBOOK_OAUTH_COOKIE_SECRET=$MOLTBOOK_OAUTH_COOKIE_SECRET
ANTHROPIC_API_KEY=$ANTHROPIC_API_KEY
EOF
log_success ".env file created at $REPO_ROOT/.env"
echo ""

# Source .env and run envsubst on all .envsubst templates
log_info "Running envsubst on templates..."
set -a
# shellcheck disable=SC1091
source "$REPO_ROOT/.env"
set +a

# Default agent name (customizable via setup-agents.sh; defaults to "shadowman" for first deploy)
export SHADOWMAN_CUSTOM_NAME="${SHADOWMAN_CUSTOM_NAME:-shadowman}"
export SHADOWMAN_DISPLAY_NAME="${SHADOWMAN_DISPLAY_NAME:-Shadowman}"

# Explicit variable list to protect {agentId} and other non-env placeholders
ENVSUBST_VARS='${CLUSTER_DOMAIN} ${OPENCLAW_PREFIX} ${OPENCLAW_NAMESPACE} ${OPENCLAW_GATEWAY_TOKEN} ${OPENCLAW_OAUTH_CLIENT_SECRET} ${OPENCLAW_OAUTH_COOKIE_SECRET} ${JWT_SECRET} ${ADMIN_API_KEY} ${POSTGRES_DB} ${POSTGRES_USER} ${POSTGRES_PASSWORD} ${MOLTBOOK_OAUTH_CLIENT_SECRET} ${MOLTBOOK_OAUTH_COOKIE_SECRET} ${ANTHROPIC_API_KEY} ${SHADOWMAN_CUSTOM_NAME} ${SHADOWMAN_DISPLAY_NAME}'

for tpl in $(find "$REPO_ROOT/manifests" "$REPO_ROOT/observability" -name '*.envsubst'); do
  yaml="${tpl%.envsubst}"
  envsubst "$ENVSUBST_VARS" < "$tpl" > "$yaml"
  log_success "Generated $(basename "$yaml")"
done
echo ""

# Select overlay based on mode
if $K8S_MODE; then
  OPENCLAW_OVERLAY="$REPO_ROOT/manifests/openclaw/overlays/k8s"
  MOLTBOOK_OVERLAY="$REPO_ROOT/manifests/moltbook/overlays/k8s"
else
  OPENCLAW_OVERLAY="$REPO_ROOT/manifests/openclaw/overlays/openshift"
  MOLTBOOK_OVERLAY="$REPO_ROOT/manifests/moltbook/overlays/openshift"
fi

# Create namespaces
log_info "Creating namespaces..."
$KUBECTL create namespace "$OPENCLAW_NAMESPACE" --dry-run=client -o yaml | $KUBECTL apply -f - > /dev/null
$KUBECTL create namespace moltbook --dry-run=client -o yaml | $KUBECTL apply -f - > /dev/null
log_success "Namespaces created: $OPENCLAW_NAMESPACE, moltbook"
echo ""

# Deploy OTEL collector for Moltbook (OpenClaw uses MLflow directly)
log_info "Deploying OpenTelemetry collector for Moltbook..."
if [ -f "$REPO_ROOT/observability/moltbook-otel-collector.yaml" ]; then
  $KUBECTL apply -f "$REPO_ROOT/observability/moltbook-otel-collector.yaml"
  log_success "Moltbook OTEL collector deployed"
else
  log_warn "Moltbook OTEL collector config not found (optional)"
fi
echo ""

if $K8S_MODE; then
  log_info "Skipping OAuthClient creation (not needed in Kubernetes mode)"
  echo ""
else
  # Deploy OAuthClients separately (cluster-scoped, can't go through Kustomize namespace transformer)
  log_info "Creating OAuthClients (requires cluster-admin)..."

  # OpenClaw OAuthClient
  if oc apply -f "$OPENCLAW_OVERLAY/oauthclient.yaml" 2>/dev/null; then
    log_success "OpenClaw OAuthClient created"
  else
    log_warn "Could not create OpenClaw OAuthClient (requires cluster-admin permissions)"
    log_warn "Ask your cluster admin to run:"
    echo "    oc apply -f $OPENCLAW_OVERLAY/oauthclient.yaml"
  fi

  # Moltbook OAuthClient
  if oc apply -f "$MOLTBOOK_OVERLAY/oauthclient.yaml" 2>/dev/null; then
    log_success "Moltbook OAuthClient created"
  else
    log_warn "Could not create Moltbook OAuthClient (requires cluster-admin permissions)"
    log_warn "Ask your cluster admin to run:"
    echo "    oc apply -f $MOLTBOOK_OVERLAY/oauthclient.yaml"
  fi
  echo ""
fi

# Deploy Moltbook
log_info "Deploying Moltbook with Guardrails..."
$KUBECTL apply -k "$MOLTBOOK_OVERLAY"
log_success "Moltbook deployed"
echo ""

# Deploy OpenClaw with Security Hardening
log_info "Deploying OpenClaw Gateway with security hardening..."
log_info "  ✓ ResourceQuota (namespace limits)"
log_info "  ✓ PodDisruptionBudget (HA)"
log_info "  ✓ Read-only filesystem"
log_info "  ✓ Health probes"
log_info "  ✓ Device authentication"
$KUBECTL apply -k "$OPENCLAW_OVERLAY"
log_success "OpenClaw deployed with enterprise security"
echo ""

echo ""
echo "╔════════════════════════════════════════════════════════════╗"
echo "║  Deployment Complete!                                      ║"
echo "╚════════════════════════════════════════════════════════════╝"
echo ""

if $K8S_MODE; then
  echo "Access (use port-forward):"
  echo "  kubectl port-forward svc/openclaw 18789:18789 -n $OPENCLAW_NAMESPACE"
  echo "  kubectl port-forward svc/moltbook-frontend 8080:8080 -n moltbook"
  echo "  kubectl port-forward svc/moltbook-api 3000:3000 -n moltbook"
  echo ""
  echo "Then open:"
  echo "  OpenClaw Gateway:    http://localhost:18789"
  echo "  Moltbook Frontend:   http://localhost:8080"
  echo "  Moltbook API:        http://localhost:3000"
  echo ""
  echo "Optional - Tracing (otel-collector + Jaeger):"
  echo "  # Install otel-collector + Jaeger in the $OPENCLAW_NAMESPACE namespace:"
  echo "  # See: https://github.com/llm-d/llm-d/tree/main/docs/monitoring"
  echo "  # Or run: install-otel-collector-jaeger.sh -n $OPENCLAW_NAMESPACE"
  echo "  #"
  echo "  # Then access Jaeger UI:"
  echo "  kubectl port-forward svc/jaeger-collector 16686:16686 -n $OPENCLAW_NAMESPACE"
  echo "  # Open http://localhost:16686"
  echo ""
else
  # Get routes
  log_info "Getting routes..."
  MOLTBOOK_FRONTEND_ROUTE=$(oc get route moltbook-frontend -n moltbook -o jsonpath='{.spec.host}' 2>/dev/null || echo "")
  MOLTBOOK_API_ROUTE=$(oc get route moltbook-api -n moltbook -o jsonpath='{.spec.host}' 2>/dev/null || echo "")
  OPENCLAW_ROUTE=$(oc get route openclaw -n "$OPENCLAW_NAMESPACE" -o jsonpath='{.spec.host}' 2>/dev/null || echo "")

  echo "Access URLs:"
  echo "  Moltbook Frontend (OAuth): https://${MOLTBOOK_FRONTEND_ROUTE}"
  echo "  Moltbook API (public):     https://${MOLTBOOK_API_ROUTE}"
  echo "  OpenClaw Gateway:          https://${OPENCLAW_ROUTE}"
  echo ""
fi

echo "Credentials:"
echo "  OpenClaw Gateway Token: $OPENCLAW_GATEWAY_TOKEN"
echo "  Moltbook Admin API Key: $ADMIN_API_KEY"
echo "  PostgreSQL:"
echo "    Database: $POSTGRES_DB"
echo "    User:     $POSTGRES_USER"
echo "    Password: $POSTGRES_PASSWORD"
echo ""

echo "Next steps — deploy AI agents:"
echo "  1. Wait for OpenClaw to be ready:"
echo "     $KUBECTL rollout status deployment/openclaw -n $OPENCLAW_NAMESPACE --timeout=600s"
echo "  2. Run the agent setup script:"
echo "     scripts/setup-agents.sh$(if $K8S_MODE; then echo ' --k8s'; fi)"
echo ""

log_success "Setup complete!"
echo ""
