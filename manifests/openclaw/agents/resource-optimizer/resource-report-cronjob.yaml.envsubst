# K8s CronJob that generates resource reports.
# Runs independently of the LLM â€” no model needed for data collection.
#
# Flow:
# 1. Queries K8s API for pods, deployments, PVCs in resource-demo namespace
# 2. Builds a structured plain-text report
# 3. Prints report to stdout (visible in job logs)
# 4. Writes report to resource-report-latest ConfigMap (read by the agent)
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: resource-report
  namespace: ${OPENCLAW_NAMESPACE}
  labels:
    app: openclaw
    agent: resource-optimizer
spec:
  schedule: "0 */8 * * *"
  timeZone: "UTC"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    metadata:
      labels:
        app: openclaw
        job: resource-report
    spec:
      backoffLimit: 2
      activeDeadlineSeconds: 120
      template:
        metadata:
          labels:
            app: openclaw
            job: resource-report
        spec:
          restartPolicy: Never
          serviceAccountName: resource-optimizer-sa
          containers:
          - name: report
            image: registry.access.redhat.com/ubi9/nodejs-20-minimal:latest
            imagePullPolicy: IfNotPresent
            resources:
              requests:
                cpu: 100m
                memory: 128Mi
              limits:
                cpu: 200m
                memory: 256Mi
            env:
            - name: K8S_NAMESPACE
              value: "resource-demo"
            command:
            - /bin/sh
            - -c
            - |
              set -e

              K8S_API="https://kubernetes.default.svc"
              CA="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
              TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              NS="$K8S_NAMESPACE"

              echo "Querying K8s API for namespace: $NS"

              curl -s -H "Authorization: Bearer $TOKEN" --cacert "$CA" \
                "$K8S_API/api/v1/namespaces/$NS/pods" > /tmp/pods.json
              curl -s -H "Authorization: Bearer $TOKEN" --cacert "$CA" \
                "$K8S_API/apis/apps/v1/namespaces/$NS/deployments" > /tmp/deployments.json
              curl -s -H "Authorization: Bearer $TOKEN" --cacert "$CA" \
                "$K8S_API/api/v1/namespaces/$NS/persistentvolumeclaims" > /tmp/pvcs.json

              echo "Building resource report..."

              node -e "
              const fs = require('fs');
              const https = require('https');

              const pods = JSON.parse(fs.readFileSync('/tmp/pods.json', 'utf8'));
              const deployments = JSON.parse(fs.readFileSync('/tmp/deployments.json', 'utf8'));
              const pvcs = JSON.parse(fs.readFileSync('/tmp/pvcs.json', 'utf8'));
              const date = new Date().toISOString().replace('T', ' ').substring(0, 19) + ' UTC';
              const ns = process.env.K8S_NAMESPACE;

              let report = 'Resource Report: ' + ns + '\n';
              report += 'Generated: ' + date + '\n';
              report += '='.repeat(60) + '\n\n';

              // Pods
              report += '## Pods\n\n';
              const podItems = (pods.items || []);
              if (podItems.length === 0) { report += '(no pods found)\n\n'; }
              podItems.forEach(p => {
                const res = (p.spec.containers[0] || {}).resources || {};
                const cpuReq = (res.requests || {}).cpu || 'none';
                const memReq = (res.requests || {}).memory || 'none';
                const cpuLim = (res.limits || {}).cpu || 'none';
                const memLim = (res.limits || {}).memory || 'none';
                report += '- ' + p.metadata.name + '\n';
                report += '  phase: ' + p.status.phase + '\n';
                report += '  cpu: request=' + cpuReq + ' limit=' + cpuLim + '\n';
                report += '  memory: request=' + memReq + ' limit=' + memLim + '\n';
              });

              // Deployments
              report += '\n## Deployments\n\n';
              const depItems = (deployments.items || []);
              if (depItems.length === 0) { report += '(no deployments found)\n\n'; }
              depItems.forEach(d => {
                const desired = d.spec.replicas;
                const available = d.status.availableReplicas || 0;
                const idle = desired === 0 ? ' [IDLE]' : '';
                const mismatch = (desired > 0 && available < desired) ? ' [DEGRADED]' : '';
                report += '- ' + d.metadata.name + ': ' + available + '/' + desired + ' replicas' + idle + mismatch + '\n';
              });

              // PVCs
              report += '\n## PVCs\n\n';
              const pvcItems = (pvcs.items || []);
              if (pvcItems.length === 0) { report += '(no PVCs found)\n\n'; }

              // Check which PVCs are mounted
              const mountedPvcs = new Set();
              podItems.forEach(p => {
                (p.spec.volumes || []).forEach(v => {
                  if (v.persistentVolumeClaim) mountedPvcs.add(v.persistentVolumeClaim.claimName);
                });
              });

              pvcItems.forEach(v => {
                const attached = mountedPvcs.has(v.metadata.name) ? 'attached' : 'UNATTACHED';
                report += '- ' + v.metadata.name + ': ' + v.spec.resources.requests.storage + ' (' + attached + ')\n';
              });

              // Summary
              report += '\n## Summary\n\n';
              const idleCount = depItems.filter(d => d.spec.replicas === 0).length;
              const unattachedCount = pvcItems.filter(v => !mountedPvcs.has(v.metadata.name)).length;
              report += 'Total pods: ' + podItems.length + '\n';
              report += 'Total deployments: ' + depItems.length + ' (' + idleCount + ' idle)\n';
              report += 'Total PVCs: ' + pvcItems.length + ' (' + unattachedCount + ' unattached)\n';

              // Print to stdout
              console.log(report);

              // Write to ConfigMap
              const namespace = fs.readFileSync('/var/run/secrets/kubernetes.io/serviceaccount/namespace', 'utf8').trim();
              const token = fs.readFileSync('/var/run/secrets/kubernetes.io/serviceaccount/token', 'utf8');
              const ca = fs.readFileSync('/var/run/secrets/kubernetes.io/serviceaccount/ca.crt');

              const body = JSON.stringify({ data: { 'report.txt': report } });

              const req = https.request({
                hostname: 'kubernetes.default.svc',
                path: '/api/v1/namespaces/' + namespace + '/configmaps/resource-report-latest',
                method: 'PATCH',
                ca: ca,
                headers: {
                  'Authorization': 'Bearer ' + token,
                  'Content-Type': 'application/strategic-merge-patch+json',
                  'Content-Length': Buffer.byteLength(body)
                }
              }, (res) => {
                let data = '';
                res.on('data', d => data += d);
                res.on('end', () => {
                  if (res.statusCode === 200) {
                    console.log('ConfigMap resource-report-latest updated successfully');
                  } else {
                    console.error('ConfigMap update failed (HTTP ' + res.statusCode + '): ' + data);
                  }
                });
              });
              req.on('error', (e) => { console.error('ConfigMap update error: ' + e.message); });
              req.write(body);
              req.end();
              "
